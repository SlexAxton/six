var { generate } = require("escodegen")

require("./es6")

var { Tree } = require("./esom/tree")

function rewrite(src) {
  var program = Tree.create(src)

  for(var { selector: key, hook: value } of hooks) {
    program.root.select(selector).forEach(hook)
  }

  return program.compile()
}

var { filters } = require("./filters")

var hooks = Object.create({
  iterator() {
    return {
      elements: Object.keys(this).map(key=>({key, value: this[key]})),
      index: 0,
      next() {
        if (this.index >= this.elements.length)
          throw StopIteration
        return this.elements[this.index++]
      }
    }
  }
})

Object.define(hooks, require("./hooks/classes"))

Object.define(hooks, {

  ".ArrowFunctionExpression": node => {
    node.compile = ()=> {
      var ctx = node.context()
      var params = ctx.params.compile ? ctx.params.compile() : ""
      var body = ctx.body.compile(), body = ctx.expression ? `{return ${body}}` : body
      return `function(${params})${body}.bind(this)`
    }
  },

  ".Property[method=true]": node => {
    node.compile = () => {
      var ctx = node.context()
      var key = ctx.key.compile()
      var value = ctx.value
      var params = value.params && value.params.compile ? value.params.compile() : ""
      var body = value.body.compile(), body = value.expression ? `{return ${body}}`: body

      return `${key}:function(${params})${body}`
    }
  },

  ".VariableDeclarator > id.ObjectPattern": node => {
    node.properties = () => {
      var ctx = node.parent.context()
      var props = []

      ctx.id.properties.node.children.forEach(child => {
        var prop = child.context()
        var key = prop.key.compile()
        var value = prop.value.compile()
        props.push({ key, value })
      })

      return props
    }

    node.assemble = (init) => {
      var ctx = node.parent.context()
      var props = node.properties()
      var result = ""

      if (!ctx.init || (!ctx.init.matches(".Identifier") && props.length > 1)) {
        var first = props.shift()
        result += `${first.key} = ${init}, `
        props.push(first)
        init = first.key
      }

      props = props.map((prop, index) => `${prop.key} = ${init}.${prop.value}`)

      return `${result}${props.join(", ")}`
    }

    node.parent.compile = () => node.assemble(node.parent.context().init.compile())
  },

  ".BinaryExpression[operator^='is']": node => {
    node.compile = () => filters.egal(node)
  },

  ".QuasiLiteral": node => {
    node.compile = () => filters.quasi(node.context())
  },

  ".ForOfStatement": node => {
    node.compile = () => {
      var context = node.context()
      var right = context.right.compile()
      var body = context.body.compile().replace(/^{([\s\S]*)}$/, "$1")
      var dec = context.left.matches(".VariableDeclaration[kind='var']")
      var decs = []
      var left = dec ? context.left.declarations.node.first().context() : context.left.node.context()

      if (left.type === "Identifier" || (left.id && left.id.type === "Identifier")) {
        decs.push(left.compile())
        left = `${left.compile()} = _iterator.next()`
      } else if (left.type === "VariableDeclarator" && left.id.type === "ObjectPattern") {
        left.select(".ObjectPattern").forEach(node => {
          decs = decs.concat(node.properties().map(prop=>prop.key))
          left = node.assemble("_iterator.next()")
        })
      } else {
        left = `(${left.compile()})`
      }

      return `
        ${ dec ? "var " + decs.join(", ") + ";" : "" }
        void function(_iterator){
          try {
            while (true) {
              ${ left }
              ${ body }
            }
          } catch (e) { if (e !== StopIteration ) throw e }
        }.call(this, ${ right }.iterator());
      `
    }
  },

  ".Program": node => {
    var compile = node.compile
    node.compile = () => {
      var src = compile.call(node)
      return generate(Tree.create(src).ast, {
        format: {
          indent: {
            style: '  ',
            base: 0
          },
          quotes: "double",
          compact: false
        },
        comment: true
      })
    }
  }

})

Object.define(Tree.prototype, {

  compile () {
    var src = this.raw()

    this.children.reverse().forEach(child => {
      var raw = child.raw()
      var start = src.indexOf(raw)
      var end = start + raw.length
      src = src.substring(0, start) + child.compile() + src.substring(end)
    })

    return src
  },

  context() {
    var ctx = new Context(this)
    return ctx
  }

})

class Context {

  constructor(node) {
    var stack = Object.create(node)

    Object.define(stack, node.ast)
    Object.define(stack, {
      node,
      get parent() {
        if ( node.parent ) return node.parent.context()
      }
    })

    if (stack.hasOwnProperty("loc")) delete stack['loc']

    node.children.forEach(child => {
      var ctx = child.context()
      Object.defineProperty(stack, child.key, {
        get() ctx,
        enumerable: true
      })
    })

    return stack
  }

}

exports.rewrite = rewrite